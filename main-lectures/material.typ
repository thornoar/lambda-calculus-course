#import "@local/common:0.0.0": *
#import "@local/theorem:0.0.0": *
#show: theorem
#import "./template.lib.typ": *
#show: formatting

#import "@preview/cetz:0.2.2" as cz

// #set list(indent: 0.1in)
// #set enum(numbering: n => strong([#n.]))
#set enum(numbering: "(1.a)")
#set page(numbering: "1")

#let myplainstyle(ident, head, ..args) = thmstyle(ident, head, titlefmt: it => strong(underline(it)), ..args)
#let mystatestyle(ident, head, ..args) = thmstyle(ident, head, bodyfmt: emph, titlefmt: it => strong(underline(it)), ..args)

#let def = myplainstyle("definition", "Определение")
#let agr = myplainstyle("agreement", "Договорённость", numbering: none)
#let note = myplainstyle("note", "Замечание")
#let nota = myplainstyle("notation", "Нотация", numbering: none)
#let exam = myplainstyle("example", "Пример")
#let exer = myplainstyle("exercise", "Упражнение", numbering: none)
#let th = mystatestyle("theorem", "Теорема")
#let lm = mystatestyle("lemma", "Лемма")
#let state = mystatestyle("statement", "Утверждение")
#let cor = mystatestyle("corollary", "Следствие", base: "theorem")
#let prb = mystatestyle("problem", "Задача")
#let pf = proofstyle("proof", "Доказательство", titlefmt: it => underline(emph(it)))

#head([ МАТЕРИАЛ КУРСА ])

#outline()
#pagebreak()

= Конверсия и редукция

== Основные понятия

#def[
  Рассмотрим счётное множество $V = {v, v', v'', ...}$. Элементы этого множества будут называться _переменными._ Множество л-выражений, #L, --- это наименьшее множество, удовлетворяющее следующим условиям: #v(2pt)
  - $x in V ==> x in #L$;
  - $x in V,, M in #L==> (>x M) in #L$; #h(1fr) (абстракция, морально: определение функции)
  - $M in #L,, N in #L ==> (M N) in #L$. #h(1fr) (комбинация, морально: применение функции к аргументу)
]

#exam[
  л-выражения в формальной нотации:
  $
    v';\
    (v v');\
    (>v (v' v));\
    ((>v (v' v))v'');\
    (((>v (>v' (v' v))) v'')v''');
  $
]

#nota[
  - $x$, $y$, $z$, ... обозначают произвольные переменные из множества $V$.
  - $M$, $N$, $K$, ... обозначают произвольные л-выражения из #L.
  - Внешние скобки опускаются: $(>x(y z)) -> >x (y z)$.
  - Многократная абстракция сокращается:
  $
    >x_1 (>x_2 (>... (>x_n M)...)) -> >x_1,.x_2,. ... ,.x_n.. M -> >arrow(x).. M
  $
  - Многократная комбинация сокращается:
  $
    ((...((M_1 M_2)M_3)...)M_n)N -> M_1M_2...M_n N -> arrow(M)N
  $
  // - $norm(M)$ обозначает количество символов в выражении $M$.
  - Комбинация берёт приоритет над абстракцией: $>x.. y z = #l x.. (y z)$
]

#set table(
  inset: (y: 7pt),
  fill: (_, y) => {
    if (y == 0) { gray.lighten(80%) }
  },
  stroke: (_, y) => {
    if (y == 0) { (bottom: 1pt, x: 1pt) } else { (y:none, x: 1pt) }
  }
)

#def[
  Пусть $M$ --- л-выражение. Множества $TV(M),, FV(M),, BV(M) subset V$ определяются индуктивно:
  #{
    show: it => align(center, it)
    table(
      columns: (10%, 20%, 20%, 20%),
      align: left,
      table.header($M$,$TV(M)$,$FV(M)$,$BV(M)$),
      $x in V$,       ${x}$,                  ${x}$,                  $empty$,
      $>x.. N$,       ${x} union TV(N)$,      $FV(N) > {x}$,         ${x} union BV(N)$,
      $N K$,          $TV(N) union TV(K)$,    $FV(N) union FV(K)$,    $BV(N) union BV(K)$
    )
  }
]

#note[
  В данный момент существуют не вполне осмысленные л-выражения. Так, в выражении $(>x.. x y)x$ переменная $x$ выступает одновременно связанной и свободной, а в выражении $>x.. >x.. x x$ переменная $x$ связывается дважды. Обе этих проблемы можно исправить _заменой связанных переменных:_ $(>x.. x y)x -> (>u.. u y)x$, $>x.. >x.. x x -> >x.. >u.. u u$. Сейчас мы формализуем эту идею.
]

#def[
  Пусть $rrel$ --- бинарное отношение на множестве #L. Тогда $rrel$ называется _совместимым с операциями,_ если:
  $
    M &rrel N ==> >x.. M rrel >x.. N,\
    M &rrel N ==> Z M rrel Z N,\
    M &rrel N ==> M Z rrel N Z.
  $
]

#def[
  _Тождественное равенство_ ($equiv$) обозначает полностью идентичный состав символов: $>x.. x y equiv.not >u.. u y$.
]

#def[
  Отношение _ал-конгруэнтности_ ($acongr$) на #L --- это наименьшее подмножество $#L times #L$, удовлетворяющее следующим условиям:
  - $M acongr M$;
  - $>x.. M acongr >y.. (M[x -> y])$, при условии что $y in.not TV(M)$;
  - $acongr$ совместимо с операциями.
]

#def[
  Пусть $M$ --- л-выражение. $M$ называется _корректным_ в следующих случаях:
  + $M equiv x in V$;
  + $M equiv >x.. N$, причём $N$ корректно, а также $x in.not BV(N)$;
  + $M equiv N K$, причём $N,K$ корректны, а также $BV(N) sect FV(K) = empty$ и $FV(N) sect BV(K) = empty$.
]

#exer[
  Доказать, что если $M$ корректно, то $FV(M) sect BV(M) = empty$, $FV(M) union BV(M) = TV(M)$.
]

#exer[
  Пусть $M$ --- л-выражение. Доказать, что существует корректное л-выражение $N$, такое, что $M acongr N$.
]

#agr("Правило переменных")[
  Пусть л-выражения $M_1, M_2, ..., M_n$ выступают с едином контексте. Тогда мы будем предполагать, что выражение $M_1M_2...M_n$ --- корректное.
]

#def[
  л-выражение $M$ называется _замкнутым_ (или _комбинатором_), если $FV(M) = empty$. $#L^0$ обозначает множество всех замкнутых л-выражений.
]

#def[
  $M$ является _подвыражением_ $N$ ($M subset N$), если $M$ лежит во множестве $Sub(N)$:
  #align(center, table(
    columns: (10%, 35%),
    align: left,
    table.header($N$, $Sub(N)$),
    $x in V$, ${x}$,
    $>x.. K$, ${>x.. K} union Sub(K)$,
    $K_1K_2$, $Sub(K_1) union Sub(K_2) union {K_1K_2}$
  ))
]

#def[
  Пусть $F, M in #L$. Тогда
  - $F^0 M equiv M$; #hs $F^(n+1)M equiv F(F^n M)$
  - $F M^(~~ 0) equiv F$; #hs $F M^(~~ n+1) equiv (F M^(~~ n))M$
]

== Оператор подстановки и бэ-конверсия

#def[
  Пусть $M in #L$, $x in.not BV(M)$. Пусть также $N in #L$. _Результат подстановки $N$ вместо $x$_, $M[x := N]$, определяется индуктивно:
  $
    x[x := N] &equiv N;\
    y[x := N] &equiv y,, "если" y equiv.not x;\
    (>y.. M')[x := N] &equiv >y.. (M'[x := N]);\
    (M_1M_2)[x := N] &equiv (M_1[x := N])(M_2[x := N]).
  $
]

#note[
  Рассмотрим $M equiv >y.. x,, N equiv y y$. Тогда по предыдущему определению мы получаем $M[x := N] = >y.. y y$, что настораживает, ведь $M equiv >y.. x acongr >u.. x equiv M'$, тогда как $ M[x := N] = >y.. y y eq.not^alpha >u.. y y = M'[x := N]. $ Однако заметим, что такая ситуация некорректна, ведь $BV(M) sect FV(N) = {y} eq.not empty$.
]

#exer[
  Доказать, что оператор подстановки уважает ал-конгруэнтность, если рассматриваемые выражения соблюдают правило переменных. Иначе говоря,
  $
    cases(
      reverse: #true,
      // delim: "[" // ]
      M acongr M',
      N acongr N'
    ) ==> M[x := N] acongr M'[x := N'].
  $
]

#lm("о подстановке")[
  Пусть $M, N, L in #L$. Тогда если $x equiv.not y$ и $x in.not FV(L)$, то
  $
    (M[x := N])[y := L] equiv (M[y := L])[x := N[y := L]]
  $
]
#pf[
  Индукция по структуре л-выражения $M$.
  + База: $M equiv u in V$. Тогда рассмотрим три случая:
    - $u equiv x$. Тогда обе части тождественно равны $N[y := L]$, так как $x equiv.not y$.
    - $u equiv y$. Тогда обе части равны $L$, так как $L[x := ...] = L$, ведь $x in.not FV(L)$.
    - $u equiv.not x,y$. Тогда обе части равны $u$.
  + Переход.
    - $M equiv >z.. M'$. По правилу переменых и определению оператора подстановки мы имеем $z in.not FV(N L)$ и $z equiv.not x,y$. Тогда по предположению индукции
    $
      (>z.. M')[x := N][y := L] &== >z.. M'[x := N][y := L]\
      &== >z.. M'[y := L][x := N[y := L]]\
      &== (>z.. M')[y := L][x := N[y := L]].
    $
    - $M == M_1M_2$. Доказательство аналогично.
  q.e.d.
]

#def("бэ-конверсия")[
  Отношение бэ-конверсии ($conv$) --- это наименьшее подмножество $#L times #L$, удовлетворяющее следующим условиям:
  - $(>x.. M)N = M[x := N]$; #h(1fr) ($beta$-конверсия)
  - $>x.. M x = M$, при условии что $x in.not TV(M)$; #h(1fr) ($eta$-конверсия)
  - $conv$ --- отношение эквивалентности;
  - $conv$ совместимо с операциями.
  Если $M conv M$, мы говорим, что "$M$ равно $N$", или "$M$ конвертируется в $N$". Запись "$proves M conv N$" означает, что конверсию $M conv N$ можно вывести из вышеуказанных правил.
]

#th("о неподвижной точке")[
  $forall F in #L: hs exists X in #L: hs F X = X$.
]
#pf[
  Пусть $W == >x.. F(x x)$ и $X == W W$. Тогда имеем $ X == W W == (>x.. F(x x))W conv F(x x)[x := W] == F(W W) == F X, $ q.e.d.
]

#state("fallacy")[
  $forall M,N in #L: hs proves M conv N$
]
#pf[
  Рассмотрим $F == >x,.y.. y x$. Тогда для любых $M,N$ имеем
  $
    F M N == ((>x.. (>y.. y x))M)N conv (>y.. y M)N conv N M.
  $
  В частности, $F y x conv x y$. Однако
  $
    F y x == ((>x.. (>y.. y x))y)x conv (>y.. y y)x = x x.
  $
  Тогда $x y conv x x$, а значит $F_1 == >x,.y.. x y conv >x,.y.. x x == F_2$. Теперь для любого $M in #L$ имеем
  $
    M conv (>x.. x)M conv F_1 (>x.. x) M conv F_2 (>x.. x) M conv (>x.. x)(>x.. x) conv (>x.. x),
  $
  и по транзитивности $M conv (>x.. x) conv N$ для любых $M, N in #L$. В чём ошибка?
]

#lm[
  Оператор подстановки уважает конверсию. Иначе говоря, если $M conv M',, N conv N'$, то $M[x := N] conv M'[x := N']$.
]
#pf[
  Упражнение.
]

== Комбинаторы и согласованность

#def[
  - $#I == >x.. x$
  - $#K == >x,.y.. x$
  - $#KK == >x,.y.. y$
  - $#S == >x,.y,.z.. x z(y z)$
  - $#Y == >f.. (>x.. f(x x))(>x.. f(x x))$ --- комбинатор неподвижной точки: $forall F in #L: hs F(#Y F) = #Y F$.\
    Этот комбинатор позволяет моделировать простую рекурсию. РАссмотрим л-выражение $M$, определённое рекуррентной формулой:
    $
      M x == F x M.
    $
    Определим $G == >y.. >x.. F x y$. Тогда $M$ приобретает явную форму: $M == #Y G$ (упражнение).
]

#def[
  - Выражение вида $M conv N$ называется _равенством;_
  - Равенство $M conv N$ называется _замкнутым,_ если $M,N in #L^0$;
  - Пусть $cal(T)$ --- формальная теория, т.е. набор правил, с помощью которых можно выводить равенства (наподобие л-теории). Тогда $cal(T)$ называется _согласованной_ (нотация $Con(cal(T))$) если $cal(T)$ *не* доказывает все замкнутые равенства. В противном случае $cal(T)$ называется _противоречивой._
  - Если $cal(T)$ --- это набор равенств, то $#l + cal(T)$ обозначает теорию, полученную добавлением равенств из $cal(T)$ к стандартному списку аксиом бэ-конверсии.
]

#def[
  Пусть $M,N in #L$. Тогда $M$ и $N$ называются _несовместимыми_ (нотация $M inc N$), если теория $#l + (M conv N)$ противоречива.
]

#exam[
  $#I inc #K$
]
#pf[
  Имеем $#I M N conv #K M N$ для любых $M,N in #L$. По определению комбинаторов $#I$ и $#K$, имеем $M N conv M$. Подставляя $M == #I$, получаем $N conv #I hs forall N in #L$.
]

== Нормальные формы

#def[
  - л-выражение $M$ называется _бэ-нормальной формой,_ если оно *не* имеет подвыражений вида $(>x.. M)N$ или $>y.. (M y)$ (где $y in.not TV(M)$).
  - $M$ _имеет нормальную форму $N$,_ если $M conv N$ и $N$ --- нормальная форма.
]

#exam[
  - $#I$ находится в нормальной форме;
  - $#K#I$ имеет нормальную форму $>y.. #I$;
  - Комбинатор $#O = (>x.. x x)(>x.. x x)$ не имеет нормальной формы (доказательство позже).
]

#underline(strong([ Воспоминания о будущем. ]))
- Если $M$ и $N$ --- различные бэ-нф, то $#l tack.r.not M conv N$;
- $M$ может иметь максимум одну нормальную форму;
- $#O = (>x.. x x)(>x.. x x)$ не имеет нормальной формы;
- $#l$ --- согласованная теория.
// - Если $M$ и $N$ --- различные бэ-нф, то $M inc N$
// - Следствие: пусть $M$ и $N$ имеют нормальную форму. Тогда либо $M conv N$, либо $M inc N$;

== Редукция

#note[
  В правилах конверсии есть определённая асимметрия. Так, о конверсии $ (>x.. x^2 + 1)3 conv 10 $ можно сказать, что "10 является результатом _упрощения_ выражения $(>x.. x^2 + 1)3$", но никак не в обратную сторону. Сейчас мы формализуем эту асимметрию. 
]

#def[
  + Отношение $->$ (_редукция за один шаг_) --- это наименьшее подмножество $#L times #L$, такое что:
    - $(>x.. M)N -> M[x := N]$;// #h(1fr) ($->_beta$)
    - $>x.. M x -> M$, если $x in.not TV(M)$;// #h(1fr) ($->_eta$)
    - $->$ совместимо с операциями.
  + Отношение $->>$ (_редукция_) --- это замыкание $->$ до предпорядка: $->> #h(3pt) = Preord(->)$;
  + Отношение $conv$ (_конгруэнтность_ или _эквивалентность_) --- это замыкание $->>$ до отношения эквивалентности: $conv #h(3pt)= Equiv(->>)$
]

#def[
  - л-выражения вида $(>x.. M)N$ называются _$beta$-редексами;_ соотв. отношения: $->_beta$, $->>_beta$, $conv_beta$
  - л-выражения вида $>x.. M x$ называются _$eta$-редексами._ соотв. отношения: $->_eta$, $->>_eta$, $conv_eta$
  - $M$ --- _нормальная форма_ (или _в нормальной форме_), если $M$ не содержит редексов.
  - Пусть $Delta$ --- редекс в выражении $M$. Запись $M ->^Delta N$ означает, что $N$ получается из $M$ сокращением редекса $Delta$: #hs $N == M[Delta -> Delta']$
  - _Редукционный путь_ --- это последовательность (конечная или бесконечная) вида
    $
      M_0 ->^(Delta_0) M_1 ->^(Delta_1) M_2 -> ...
    $
]

#exam[
  - Определим $omega_3 == >x.. x x x$. Это выражение порождает бесконечный редукционный путь:
    $
      omega_3 omega_3 ->^(omega_3 omega_3) omega_3 omega_3 omega_3 ->^(omega_3 omega_3) omega_3 omega_3 omega_3 omega_3 ->^(omega_3 omega_3) ...
    $
  - Редекс не всегда однозначно задаётся редукцией:
    $
      #I (#I x) ->^(#I x) #I x, hs hs #I (#I x) ->^(#I (#I x)) #I x
    $
]

#state[
  Пусть $M$ --- нормальная форма. Тогда:
  + $exists.not N: hs M -> N$;
  + $M ->> N ==> M == N$.
] <uniquenf>
#pf[
  + Очевидно.
  + По определению $->>$, условие $M ->> N$ влечёт два случая:
    - $M -> K_1 -> K_2 -> ... -> N$ --- невозможно по (1);
    - $M == N$ --- искомый.
  q.e.d.
]

#def[
  _Редукционный граф_ выражения $M$ (нотация $Gr(M)$) --- это граф, в котором:
  $
    V = { N in #L | M ->> N }, hs hs E = { (N,K) in V^2 | N -> K }
  $
]

#def[
  Пусть $rel$ --- произвольное отношение на множестве $X$. $rel$ _обладает свойством Чёрча-Россера_ (нотация $CR(rel)$), если
  $
    forall x, x_1, x_2 in X: hs (x rel x_1) and (x rel x_2), hs hs exists z in X: hs (x_1 rel z) and (x_2 rel z).
  $
] <crdef>

#th[
  Пусть $rel$ рефлексивно и обладает свойством Чёрча-Россера. Тогда для отношения $~~ #h(3pt)= Equiv(rel)$ справедливо:
  $
    x ~~ y ==> exists z: hs (x rel z) and (y rel z)
  $
] <bottom>
#pf[
  Индукция по определению отношения $~~$. Пусть $x ~~ y$. Тогда возникают три случая:
  - $x ~~ y <== x rel y$. Тогда положим $z == y$.
  - $x ~~ y <== y ~~ x$. Тогда возьмём $z$ по предположению индукции.
  - $x ~~ y <== (x ~~ L) and (L ~~ y)$. Тогда рассмотрим $z_1, z_2 in #L: hs (z_1 rrel x,L) and (z_2 rrel L,y)$. Поскольку $CR(rel)$, найдётся л-выражение $z$, такое, что $(z_1 rel z) and (z_2 rel z)$. Оно искомое.
  q.e.d.
]

== Теорема Чёрча-Россера

Сначала мы докажем, что отношение $->_beta$ обладает свойством Чёрча-Россера.

#lm[
  Пусть $rel$ --- бинарное отношение на множестве $X$ и пусть $rel' = Trans(rel)$ --- его транзитивное замыкание. Тогда #hs
  $CR(rel) ==> CR(rel').$
] <transcr>
#pf[
  Пусть $x rel' x_1,, x rel' x_2$. Тогда для каждого отношения возможны два случая, и все четыре можно представить на диаграмме:
  #v(.3cm)
  #align(center, lambda-diagram(
    spacing: 1cm,
    {
      let x = (0,0)
      let u1 = (1,0)
      let u2 = (2,0)
      let w1 = (0,-1)
      let w2 = (0,-2)
      let z1 = (1,-1)
      let z2 = (2,-1)
      let z3 = (1,-2)
      let z4 = (2,-2)
      node(x, $x$)
      node(u1, $u_1$)
      node(u2, $u_2$)
      node(w1, $w_1$)
      node(w2, $w_2$)
      node(z1, $z_1$)
      node(z2, $z_2$)
      node(z3, $z_3$)
      node(z4, $z_4$)
      edge(x, u1, "-straight")
      edge(u1, u2, "-straight")
      edge(x, w1, "-straight")
      edge(w1, w2, "-straight")
      edge(w1, z1, "--straight")
      edge(u1, z1, "--straight")
      edge(w2, z3, "--straight")
      edge(u2, z2, "--straight")
      edge(z1, z2, "--straight")
      edge(z1, z3, "--straight")
      edge(z2, z4, "--straight")
      edge(z3, z4, "--straight")
    }
  ))
  q.e.d.
]

#let arr = math.arrow.r.squiggly

#def[
  Рассмотрим бинарное отношение $arr$, определённое индуктивно следующим образом:
  - $M arr M$;
  - $M arr M' ==> >x.. M arr >x.. M'$;
  - $M arr M',, N arr N' ==> M N arr M'N'$;
  - $M arr M',, N arr N' ==> (>x.. M)N arr M'[x := N']$.
]

#lm[
  Если $M arr M'$ и $N arr N'$, то $M[x := N] arr M'[x := N']$.
] <arrsubs>
#pf[
  Индукция по определению $M arr M'$.
  + $M arr M' <== M arr M$. Тогда требуется доказать, что $M[x := N] arr M[x := N']$. Проведём индукцию по структуре $M$:
    #align(center, table(
      columns: (10%, 20%, 20%, 20%),
      table.header($M$, "Правая часть", "Левая часть", "Комментарий"),
      $x$, $N$, $N'$, "ОК",
      $y$, $y$, $y$, "ОК",
      $P Q$, $P[...]Q[...]$, $P[...']Q[...']$, "предп. инд.",
      $>y.. P$, $>y.. P[...]$, $>y.. P[...']$, "аналогично"
    ))
  + $M arr M' <== >y.. P arr >y.. P'$, прямое следствие $P arr P'$. По предположению индукции имеем $P[x := N] arr P'[x := N']$, а тогда $>y.. P[x := N] arr >y.. P'[x := N']$, что и требовалось доказать.
  + $M arr M' <== P Q arr P'Q'$, где $P arr P'$ и $Q arr Q'$. Тогда имеем
    $
      M[x := N] &== P[x := N]Q[x := N]\
                &arr P'[x := N']Q'[x := N']\
                &== M'[x := N'].
    $
  + $M arr M' <== (>y.. P)Q arr P'[x := Q']$, где $P arr P'$, $Q arr Q'$. Тогда
    $
      M[x := N] &== (>y.. P[x := N])(Q[x := N])\
                &arr P'[x := N'][y := Q'[x := N']]\
                &== P'[y := Q'][x := N']\
                &== M'[x := N'].
    $
  q.e.d.
]

#lm[
  + $>x.. M arr N$ влечёт $N == >x.. M'$, где $M arr M'$;
  + $M N arr L$ влечёт либо
    - $L == M'N'$, где $M arr M'$ и $N arr N'$, либо
    - $M == >x.. P,, L == P'[x := N']$, где $P arr P',, N arr N'$.
] <pattern>
#pf[
  Очевидно.
]

#lm[
  $arr$ удовлетворяет свойству Чёрча-Россера.
]
#pf[
  Пусть $M arr M_1,, M arr M_2$. Проводим индукцию по определению $M arr M_1$.
  + $M arr M_1 <== M == M_1$. Тогда положим $Z == M_2$.
  + $M arr M_1 <== (>x.. P)Q arr P'[x := Q']$, где $P arr P'$, $Q arr Q'$. @pattern позволяет рассмотреть два подслучая:
    - $M_2 == (>x.. P'')Q''$, где $P arr P'',, Q arr Q''$. По предположению индукции существуют л-выражения $Z_P$, $Z_Q$, такие, что
    $
      P' arr Z_P,, P'' arr Z_P,, Q' arr Z_Q,, Q'' arr Z_Q.
    $ @arrsubs позволяет взять $Z == Z_P [x := Z_Q]$ в качестве искомого (упражнение).
    - $M_2 == P''[x := Q'']$ --- аналогично.
  + $M arr M_1 <== P Q arr P'Q'$, где $P arr P'$, $Q arr Q'$. Снова два подслучая:
    - $M_2 == P''Q''$, причём $P arr P''$, $Q arr Q''$. Тогда аналогично берём $Z == Z_P [x := Z_Q]$.
    - $P == (>x.. P_1)$, $M_2 == P_1''[x := Q'']$ и $P_1 arr P_1''$, $Q arr Q''$. @pattern гарантирует, что $P' == >x.. P_1'$, где $P_1 arr P_1'$. Применяя предположение индукции, берём $Z = Z_P [x := Z_Q]$.
  + $M arr M_1 <== >x.. P arr >x.. P'$, где $P arr P'$. Тогда $M_2 == >x,, P''$. По предположению индукции возьмём $Z = >x.. Z_P$.
  q.e.d.
]

#lm[
  $->_beta$ --- это транзитивное замкание $arr$.
]
#pf[
  Очевидно по определению.
]

#th("Чёрча-Россера")[
  + $->_beta$ удовлетворяет свойству Ч.-Р.;
  + $M conv_beta N ==> exists Z: hs (M ->_beta Z) and (N ->_beta Z)$.
]
#pf[
  Упражнение.
]

#cor[
  + Если $M$ имеет б-нормальную форму $N$, то $M ->>_beta N$.
  + $M$ может иметь максимум одну нормальную форму.
]
#pf[
  + Пусть $M conv_beta N$, где $N$ --- б-нормальная форма. Тогда существует л-выражение $Z$, такое, что $M ->>_beta Z$ и $N ->>_beta Z$ (@bottom). Однако раз $N$ --- нормальная форма, мы заключаем, что $N == Z$ (@uniquenf), и $M ->>_beta N$.
  + Пусть $N_1, N_2$ --- б-нормальнве формы выражения $M$. Тогда $N_1 ->>_beta Z$ и $N_2 ->>_beta Z$ для некоторого $Z$. Следовательно, $N_1 == Z == N_2$.
  q.e.d.
]

Теперь мы перейдём к эт-редукции.

#def[
  Пусть $rel1, rel2, rel3, rel4$ --- бинарные отношения на множестве $X$. Следующая диаграма,
  #diamond-diagram(
    spacing: 1cm,
    $rel1$,
    $rel2$,
    $rel3$,
    $rel4$
  )
означает "$forall x, x_1, x_2 in X: hs (x rel1 x_1) and (x rel2 x_2), hs hs exists z in X: hs (x_2 rel3 z) and (x_1 rel4 z)$".
]

#note[
  Свойство Чёрча-Россера можно переформулировать в этой нотации.
]

#def[
  Пусть $rel1$ и $rel2$ --- два бинарных отношения на $X$. Мы говорим, что $rel1$ и $rel2$ _коммутируют,_ если
  #diamond-diagram(
    spacing: 1cm,
    $rel1$,
    $rel2$,
    $rel1$,
    $rel2$
  )
]

#note[
  Отношение $rel$ обладает свойством Ч.-Р. $<=>$ $rel$ коммутирует само с собой.
]

#state("лемма Хиндли-Росена")[
  Пусть $rel1$, $rel2 #h(2pt) subset X times X$ таковы, что
  + $CR(rel1), CR(rel2)$;
  + $rel1$ и $rel2$ коммутируют.
  Тогда #h(2pt) $Trans(rel1 union rel2)$ также обладает свойством Чёрча-Россера.
]
#pf[
  Упражнение.
]

#lm[
  Пусть $rel1, rel2$ --- бинарные отношения на множестве $X$. Допустим также, что
  #diamond-diagram(
    spacing: 2cm,
    $rel1$,
    $rel2$,
    $Refl(rel1)$,
    $Preord(rel2)$
  )
  Тогда отношения $Preord(rel1)$ и $Preord(rel2)$ коммутируют.
] <commute>
#pf[
  Диаграммный поиск (лень рисовать).
]

#lm[
  $->>_eta$ удовлетворяет свойству Чёрча-Россера.
]
#pf[
  Так как $->>_eta hs = Preord(->_eta) = Trans(Refl(->_eta))$, достаточно доказать утверждение для отношения $Refl(->_eta) =: hs (arr)$ (@transcr). Предположим теперь, что $M arr M_1$ и $M arr M_2$. Без ограничения общности, допустим, что все три выражения $M, M_1, M_2$ различны (иначе очевидно). Индукция по определению $M arr M_1$:
  + $M arr M_1 <== >x.. P x arr P$. Тогда $M_2 = >x.. P'x$, где $P arr P'$. Положим $Z == P'$ и дело в шляпе.
  + $M arr M_1 <== K P arr K P'$, где $P arr P'$. Тогда если $M_2 == K' P$, $K arr K'$, то положим $Z == K' P'$. Если же $M_2 == K P''$, $P' arr P''$, то воспользуемся предположением индукции: $exists Z_P : hs P', P'' arr Z_P$. Положим $Z = K Z_P$.
  + $M arr M_1 <== P K arr P' K$, где $P arr P'$. Аналогично с предыдущим случаем.
  + $M arr M_1 <== >x.. P arr >x.. P'$, где $P arr P'$.
    + $M_2 == >x.. P''$, $P arr P''$. Тогда положим $Z == >x.. Z_P$, где $Z_P$ взято из предположения индукции.
    + $P == P_0 x$, $M_2 == P_0$. Тогда $P' == P'_0 x$, и мы можем положить $Z == P'_0$.
  q.e.d.
]

#lm[
  $->>_beta$ коммутирует с $->>_eta$.
]
#pf[
  @commute сводит доказательство к следующей диаграмме:
  #diamond-diagram(
    prepad: -10pt,
    spacing: 1.8cm,
    $->_beta$,
    $->_eta$,
    $Refl(->_beta)$,
    $->>_eta$
  )
  Упражнение.
]

#th([теорема Чёрча-Россера для бэ-редукции])[
  + $->>$ удовлетворяет свойству Чёрча-Россера;
  + $M conv N ==> exists Z: hs (M ->> Z) and (N ->> Z)$.
]
#pf[
  Упражнение.
]

#cor[
  - Если $M$ имеет бэ-нормальную форму $N$, то $M ->> N$;
  - $M$ может иметь максимум одну нормальную форму;
  - Теория $#l beta eta$ согласованна;
  - л-выражение $#O = (>x.. x x)(>x.. x x)$ не имеет нормальной формы.
]
#pf[
  Очевидно, применяя @uniquenf.
]

== Редукционные стратегии

#def("редукционная стратегия")[
  Отображение $F : #L -> #L$ называется _редукционной стратегией,_ если для любого $M in #L$ выполняется редукция $ M ->> F(M). $
]

#def[
  Редукционная стратегия $F$ называется _нормализующей,_ если лдя любого $M in #L$, имеющего нф, $F^n (M)$ находится в нормальной форме для некоторого $n in NN$.
]

#def[
  _Крайняя левая редукционная стратегия,_ $F_l$, определяется следующим образом:
  - $F_l (M) = M$, если $M$ в нормальной форме.
  - $F_l (M) = M'$, если $M ->^Delta M'$, где $Delta$ --- крайний левый (внешний) редекс в $M$.
]

#th("о нормализации")[
  $F_l$ --- нормализующая стратегия.
]
#pf[
  Без доказательства.
]

= л-представимость
